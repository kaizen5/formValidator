/**
 * FORM VALIDATOR:
 *
 * TO USE:
 * 1) Must have a container that defines the form area (does not have to be a <form> element)
 * 2) Add data-validate='[RULESET]' to any element.
 * 3) Only add data-required=false if it is optional.  We assume it is required if not.
 * 4) In your layout JS, include this module, and create new validator per form:
 *    this.shippingValidator = new Validator([formSelectorString], [rules object], [overrides object])
 */
import extend from 'extend';

/* SETTINGS:
 * {string}  errorClass
 * {string}  errorElement (OPTIONS: 'parent' | 'self')
 * {string}  errorMsgContainer
 *
 * {boolean} validateHidden
 *
 * {boolean} events.blur (enable/disable auto-binding events)
 * {boolean} events.keyup
 * {boolean} events.change
 *
 * {function} addError (override UX handling)
 * {function} removeError
*/

/**
 * Validator Constructor
 * @param {string} form     Selector String for the form.
 * @param {object} master   Master rules will be generated by service.
 *                          For now, it is pulled from US_Validation_Rules.json then passed in.
 * @param {object} settings Settings for the validator.  Settings will grow with needs.
 */
let Validator = function(formSelector, masterRules, settings) {
  let formElements = [];

  this.formSelector = formSelector;
  this.master = masterRules;
  this.addError = settings.addError || this.addError;
  this.removeError = settings.removeError || this.removeError;
  this.rules = {};
  this.status = {};
  this.events = {keyup: {}};
  this.valid = false;

  // Settings Overrides
  extend(true, this.config, settings);

  // Gather Form Elements to build Form Data Model
  formElements = document.querySelector(this.formSelector)
                         .querySelectorAll('input, select, textarea');

  // Build Validator Data Model AND Assign Event Handling
  for (let key = 0; key < formElements.length; key++) {
    let i = formElements[key];
    let iName = i.name;
    let ruleset = i.dataset.validate;

    if (ruleset) {
      this.rules[iName] = this.master.rulesets[ruleset];
      this.status[iName] = false;
    }

    // Bind Events
    if (i.type === 'radio' ||
        i.type === 'checkbox' ||
        i.type === 'select-one' ||
        i.type === 'select-multiple') {
      this.bindChangeEvent(i);
    } else {
      this.bindBlurEvent(i);
    }
  }

};

/**
 * Default Validator Setup
 * @type {Object}
 */
Validator.prototype.config = {
  errorClass: 'is-error',
  errorElement: 'self',
  errorMsgContainer: null,
  validateHidden: false,

  events: {
    blur: true,
    keyup: true,
    change: true
  }
};

/**
 * Validates all inputs that have rules within the current form.
 * @return {boolean} isValid  If entire form is valid, return true
 */
Validator.prototype.validateForm = function() {
  let self = this;
  let isValid;
  let isValidForm = true;

  Object.keys(this.rules).forEach(function(inputName) {
    isValid = (self.validateSingle(inputName)) ? true : false;
    if (!isValid) {
      isValidForm = false;
    }
  });

  this.status._all = isValidForm;
  return isValidForm;
};

/**
 * Gatekeeper for validation.  Routes to required validation
 * type and rulesets.
 * @param  {string} inputName Name of input to validate
 * @return {boolean}          is valid?
 */
Validator.prototype.validateSingle = function(inputName) {
  let isValid = true;
  let input = document.querySelector(this.formSelector)
                      .querySelectorAll(`[name=${inputName}]`);
  let rules = this.rules[input[0].name];
  let noTextInput = (input[0].type === 'radio' ||
                     input[0].type === 'checkbox' ||
                     input[0].type === 'select-one' ||
                     input[0].type === 'select-multiple');

  // No rules?
  if (!rules && !noTextInput) {
    // console.error('Validator: No rules found for:', inputName);
    return true;
  }

  // Hidden?  Don't validate.
  if (!this.isVisible(input[0])) {
    return true;
  }

  // Route Rules by Input Type
  switch (input[0].type) {
    case 'radio':
      isValid = this.validateRadio(input);
      break;
    case 'checkbox':
      isValid = this.validateCheckbox(input[0], inputName);
      break;
    case 'select-one':
    case 'select-multiple':
      isValid = this.validateSelect(input[0], inputName);
      break;

    // Text / Tel / Email / Textarea etc.
    default:
      isValid = this.validateText(input[0], inputName);

      // Apply keydown event if not added already
      if (this.config.events.keyup && !this.events.keyup[inputName]) {
        this.bindKeyUpEvent(input[0]);
        this.events.keyup[inputName] = true;
      }
      break;
  }

  return isValid;
};

/**
 * Validate inputs that require text input.
 * @param  {Node} el input element to validate
 * @param  {string}  name name of input to validate
 * @return {[type]}           [description]
 */
Validator.prototype.validateText = function(el, name) {
  let isRequired = (el.dataset.required === 'false') ? false : true;
  let rules = this.rules[name];
  let self = this;
  let isValid = true;

  // Empty and Not Required? Make valid, and EARLY RETURN.
  if (!isRequired && !el.value.length) {
    if (!this.status[name]) {
      this.removeError(el);
      this.status[name] = true;
    }
    return true;
  }

  // Run validation for each rule
  Object.keys(rules).forEach(function(key) {
    // If still valid, continue testing.
    if (isValid) {
      let ruleValue = rules[key];

      // If ruleValue is a boolean, we know it will be consuming a regex pattern
      // to match against, use regexMatch().  Else, validate using the ruleValue passed in.
      if (typeof ruleValue === 'boolean') {
        // Methods may return array of matched vars which is truthy.
        // May also return null, and we need !!boolean to update this.status.
        isValid = !!self.methods.regexMatch.call(self, el, key);
      } else {
        isValid = self.methods[key].call(self, el, ruleValue);
      }

      // If freshly invalid, update UI
      if (!isValid) {
        self.addError(el, self.generateErrorMsg(el, key, ruleValue));
      }
    }
  });

  // Remove Error State if previously invalid
  if (isValid && !this.status[name]) {
    this.removeError(el);
  }

  // Update Status
  this.status[name] = isValid;

  return isValid;
};

/**
 * Using radio assumes that a selection is required.
 * @param {Node} el Radio Input being validated
 * @return {boolean} Is valid?
 */
Validator.prototype.validateRadio = function(el) {
  let isValid = false;

  for (let x = 0; x < el.length; x++) {
    if (el[x].checked) {
      isValid = true;
      break;
    }
  }

  if (!isValid) {
    this.addErrorMulti(el, this.master.rules.required.message);
  } else if (!this.status[el[0].name]) {
    this.removeErrorMulti(el);
  }

  return isValid;
};

/**
 * Checkboxes have one validation.  Required or not.
 * @param {Node} el Checkbox Input being validated
 * @param {string} name Name of input.
 * @return {boolean} Is valid?
 */
Validator.prototype.validateCheckbox = function(el, name) {
  let isValid = true;

  if (el.dataset.validate === 'required' && !el.checked) {
    isValid = false;
    this.addError(el);
  } else if (!this.status[name]) {
    this.removeError(el);
  }

  return isValid;
};

/**
 * Selects have one validation; if a value has been selected or not.
 * Assumes first option and/or a null value is NOT permitted.
 * @param {Node} el Select Input being validated
 * @param {string} name Name of input.
 * @return {boolean} Is valid?
 */
Validator.prototype.validateSelect = function(el, name) {
  let isValid = true;

  if (el.dataset.validate === 'required' && (!el.selectedIndex || el.value === '')) {
    isValid = false;
    this.addError(el, this.master.rules.required.message);
  } else if (!this.status[name]) {
      this.removeError(el);
  }

  return isValid;
};

/***************************** ERROR HANDLING *****************************/

/**
 * Add error state to validated input
 * @param {Node} input Input element validated to false
 * @param {string}  msg    Error Message
 */
Validator.prototype.addError = function(input, msg) {
  let parent = input.parentNode;
  let errorEl = (this.config.errorElement === 'parent') ? parent : input;
  let msgContainer;

  addClass(errorEl, this.config.errorClass);

  if (msg) {
    msgContainer = parent.querySelector(this.config.errorMsgContainer);
    if (msgContainer) {
      msgContainer.textContent = msg;
    }
  }
};

/**
 * Remove error state from validated input
 * @param {Node} input Input element validated to true
 */
Validator.prototype.removeError = function(input) {
  let parent = input.parentNode;
  let msgContainer = parent.querySelector(this.config.errorMsgContainer);
  let errorEl = (this.config.errorElement === 'parent') ? input.parentNode : input;

  removeClass(errorEl, this.config.errorClass);

  if (msgContainer) {
    msgContainer.textContent = null;
  }
};

/**
 * Add error state for inputs being validated together.
 * Radios/Checkboxes
 * @param {NodeList} inputs Contains multiple inputs
 * @param {string} msg    Error Message
 */
Validator.prototype.addErrorMulti = function(inputs, msg) {
  let self = this;
  let msgContainer = inputs[inputs.length - 1].parentNode.querySelector(this.config.errorMsgContainer);

  for (let key = 0; key < inputs.length; key++) {
    let parent = inputs[key].parentNode;
    let errorEl = (self.config.errorElement === 'parent') ? parent : inputs[key];

    addClass(errorEl, self.config.errorClass);
  }

  if (msg && msgContainer) {
    msgContainer.textContent = msg;
  }
};

/**
 * Remove error states for inputs that are validated together.
 * Radios/Checkboxes
 * @param {NodeList} inputs Contains multiple inputs
 * @param {string} msg    Error Message
 */
Validator.prototype.removeErrorMulti = function(inputs) {
  let self = this;
  let msgContainer = inputs[inputs.length - 1].parentNode.querySelector(this.config.errorMsgContainer);

  for (let key = 0; key < inputs.length; key++) {
    let parent = inputs[key].parentNode;
    let errorEl = (self.config.errorElement === 'parent') ? parent : inputs[key];

    removeClass(errorEl, self.config.errorClass);
  }

  if (msgContainer) {
    msgContainer.textContent = null;
  }
};

/*************************** VALIDATOR EVENTS ***************************/

/**
 * Bind change event to selects, checkboxes, and radios.
 * @param  {Node} el Input to be bound to
 * @return {undefined}
 */
Validator.prototype.bindChangeEvent = function(el) {
  let self = this;

  if (this.config.events.change) {
    el.addEventListener('change', function() {
      self.validateSingle(el.name);
    });
  }
};

/**
 * Bind blur event to desired text-based inputs.
 * @param  {Node} el Input to be bound to
 * @return {undefined}
 */
Validator.prototype.bindBlurEvent = function(el) {
  let self = this;

  if (this.config.events.blur) {
    el.addEventListener('blur', function() {
      let hasEvent = self.events.keyup[el.name];
      self.validateSingle(el.name);

      if (self.config.keyup && !hasEvent) {
        self.bindKeyUpEvent(el);
      }
    });
  }
};

/**
 * Bind keyup event to desired input.
 * @param  {Node} el Input to be bound to
 * @return {undefined}
 */
Validator.prototype.bindKeyUpEvent = function(el) {
  let self = this;
  if (el.type === 'radio' || el.type === 'checkbox' || el.type === 'select') {
    return;
  }

  el.addEventListener('keyup', function() {
    self.validateSingle(el.name);
  });

  this.events.keyup[el.name] = true;
};

/*************************** VALIDATOR HELPERS ***************************/
/**
 * Simplified isVisible helper.
 * - Verify width/height > 0
 * - Verify offsetWidth/offsetHeight > 0
 * Does not account for elements way of the viewport.
 * @param  {Node}  el HTML Element
 * @return {boolean}  is visible?
 */
Validator.prototype.isVisible = function(el) {
  // Radios/Checkboxes are hidden and the label handles UI.  Check for label instead.
  if (el.type === 'radio' || el.type === 'checkbox') {
    let inputId = el.id;
    let label = document.querySelector(this.formSelector)
                        .querySelector(`[for=${inputId}]`);
    el = label;
  }

  let isVis = true;
  let rect = el.getBoundingClientRect();
  if (rect.height === 0 ||
      rect.width === 0 ||
      el.offsetWidth === 0 ||
      el.offsetHeight === 0) {
    isVis = false;
  }

  return isVis;
};

/**
 * If error message needs a variable replacement, swap out variable
 * and return.  Otherwise, return msg unmodified.
 * NOTE: Only allows for ONE variable currently.
 * @param  {string} ruleKey   Object key for rules
 * @param  {number} ruleValue Rule value
 * @return {string} Error message
 */
// Validator.prototype.generateErrorMsg = function(ruleKey, ruleValue) {
//   let msg = this.master.rules[ruleKey].message;
//   return msg.replace('{0}', ruleValue);
// };

Validator.prototype.generateErrorMsg = function(el, ruleKey, ruleValue) {
  let msg;

  if (typeof ruleValue === 'boolean') {
    msg = this.generateInvalidChars(el, ruleKey);
  } else {
    msg = this.master.rules[ruleKey].message.replace('{0}', ruleValue);
  }

  return msg;

};

/**
 * Generate detailed error message with invalid character list.
 * @param  {Node} el        input element
 * @param  {string} ruleKey name of rule
 * @return {string}         Detailed error message.  Ex) 'Invalid characters: $, @'
 */
Validator.prototype.generateInvalidChars = function(el, ruleKey) {

 // Only unique values permitted.  Don't duplicate invalid chars:
  let msg = this.master.rules[ruleKey].message;
  let match = this.master.rules[ruleKey].match;
  let pattern = this.master.rules[ruleKey].pattern;
  let invalidChars = new Set();
  let charMsg = '';

  if (msg.indexOf('{0}') !== -1 && pattern) {
    el.value.split('').forEach((char) => {
      if (match ? !pattern.test(char) : pattern.test(char)) {
        invalidChars.add(char);
      }
    });

    for (let char of invalidChars) { // eslint-disable-line
      charMsg += !charMsg ? char : `,  ${char}`;
    }
    msg = msg.replace('{0}', charMsg);
  }

  return msg;
};

/**************** VALIDATOR RULE HANDLING.  THE MAGIC. ****************/

/**
 * Each rule that is returned from (fake) service should be mapped
 * and handled here.
 * @type {Object}
 */
Validator.prototype.methods = {

  regexMatch(input, rule) {
    let isValid = true;

    if (rule) {
      isValid = validateRegEx(input.value.trim(), this.master.rules[rule].pattern, this.master.rules[rule].match);
    }

    return isValid;
  },

  // Rule = number
  minLength(input, minVal) {
    let isValid = (input.value.length >= minVal) ? true : false;
    return isValid;
  },

  // Rule = number
  maxLength(input, maxVal) {
    let isValid = (input.value.length <= maxVal) ? true : false;
    return isValid;
  }

};

/*************** PRIVATE HELPER METHODS ***************/

/**
 * Receives value and pattern, and if matched, returns it.
 * @param  {string} value   Value of input
 * @param  {regex} pattern  Pattern to be validated against
 * @param  {boolean} match  Test for inclusion or exclusion
 * @return {array}          Returns array of matches.
 */
let validateRegEx = function(value, pattern, match) {
  let isValid = value.match(pattern);
  return (match) ? isValid : !isValid;
};

/**
 * Add class to classList with fallback.
 * @param {Node} el
 */
let addClass = function(el, className) {
  if (el.classList){
    el.classList.add(className);
  } else {
    el.className += ' ' + className;
  }
};

/**
 * Remove class from classList with regex fallback.
 * @param {Node} el
 */
let removeClass = function(el, className) {
  if (el.classList) {
    el.classList.remove(className);
  } else {
    el.className = el.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
  }
};

/**
 * Service will return a regex pattern as a string.
 * Convert to regex to be used with validator.
 * @param  {string} rxStr String with Regular Expression
 * @return {regex}        Return regex object.
 let regexFromString = function(rxStr) {
  let flags = rxStr.replace(/.*\/([gimy]*)$/, '$1');
  let pattern = rxStr.replace(new RegExp('^/(.*?)/' + flags + '$'), '$1');
  return new RegExp(pattern, flags);
};
*/

module.exports = Validator;

